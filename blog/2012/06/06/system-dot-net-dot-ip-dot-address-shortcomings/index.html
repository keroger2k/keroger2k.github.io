
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>System.Net.IP.Address Shortcomings - Kyle Rogers</title>
  <meta name="author" content="Kyle Rogers">

  
  <meta name="description" content="Dealing with the lack of support for a true IPAddress object within .NET">
  <meta name="keywords" content="asp.net, C#, ipaddress, system.net.ipaddress">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://keroger2k.github.io/blog/2012/06/06/system-dot-net-dot-ip-dot-address-shortcomings">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Kyle Rogers" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-12440821-4']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Kyle Rogers</a></h1>
  
    <h2>clever subtitle here</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:keroger2k.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">System.Net.IP.Address Shortcomings</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-06T15:35:00-05:00" pubdate data-updated="true">Jun 6<span>th</span>, 2012</time>
        
      </p>
    
  </header>


<div class="entry-content"><h1>Overview</h1>

<p>Perhaps I&rsquo;m going about this completely the wrong way, but from what I can tell, there really isn&rsquo;t much logic built into the framework for IP Addressing and C#. There is a <a href="http://msdn.microsoft.com/en-us/library/system.net.ipaddress.aspx">System.Net.IPAddress</a> class that has some very limited capabilities IMO. I just don&rsquo;t understand why there isn&rsquo;t some additional functionality with this class or some sister class that helps simplify common tasks with IP address functionality. For example an IP address is mostly useless alone. Without a subnet mask you have no real sense of the IP address. Once you have the subnet mask you then can extrapolate all the details such as network address, broadcast address, size, etc&hellip; I wish the System.Net.IPAddress class allowed you to do more things like this natively.</p>

<p>Below are a few methods to help extend on the logic of System.Net.IPAddress. I thought I&rsquo;d share what has been completed so far. I&rsquo;ve also included the NUnit test cases that go along with this class to help with understanding what each of the methods are doing.</p>

<h1>The Code</h1>

<div><script src='https://gist.github.com/2884281.js?file=IPHelper.cs'></script>
<noscript><pre><code>public class IPHelper : IIPHelper {
    /// &lt;summary&gt;
    /// Verifies IP Address is Valid
    /// &lt;/summary&gt;
    public bool ip_inside_range(string subnet, string ipAddress) {
      string[] token = subnet.Split('/');
      string mask = token[1].Contains(&quot;.&quot;) ? token[1] : ip_cidrtomask(byte.Parse(token[1]));
      uint networkAddress = ip_iptouint(ip_networkAddress(token[0], mask));
      uint broadcastAddress = ip_iptouint(ip_broadcastAddress(token[0], mask));
      uint ip = ip_iptouint(ipAddress);
      return (networkAddress &lt; ip &amp;&amp; ip &lt; broadcastAddress);
    }
    /// &lt;summary&gt;
    /// Verifies IP Address is Valid
    /// &lt;/summary&gt;
    public bool valid_ip(string address) {
      try {
        IPAddress test = IPAddress.Parse(address);
        return true;
      } catch (FormatException) {
        return false;
      }
    }
    /// &lt;summary&gt;
    /// Takes an IP address string value in dotted decial format and convert it to a uint value
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;ip&quot;&gt;String value of the IP address in dotted decimal format (i.e. 192.168.10.1)&lt;/param&gt;
    /// &lt;returns&gt;Unsigned integer value that represents the IP address passed in&lt;/returns&gt;
    public uint ip_iptouint(string ip) {
      IPAddress i = IPAddress.Parse(ip);
      byte[] ipByteArray = i.GetAddressBytes();

      uint ipUint = (uint)ipByteArray[0] &lt;&lt; 24;
      ipUint += (uint)ipByteArray[1] &lt;&lt; 16;
      ipUint += (uint)ipByteArray[2] &lt;&lt; 8;
      ipUint += (uint)ipByteArray[3];

      return ipUint;
    }
    /// &lt;summary&gt;
    /// Convert a uint IP address value to a string value in dotted decimal format
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;ip&quot;&gt;Unsigned integer value of IP address&lt;/param&gt;
    /// &lt;returns&gt;String value of the IP address in dotted decimal format&lt;/returns&gt;
    public string ip_uinttoip(uint ip) {
      IPAddress i = new IPAddress(ip);
      string[] ipArray = i.ToString().Split('.');
      
      return ipArray[3] + &quot;.&quot; + ipArray[2] + &quot;.&quot; + ipArray[1] + &quot;.&quot; + ipArray[0];
    }
    /// &lt;summary&gt;
    /// Converts the subnet mask into CIDR notation
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Mask&quot;&gt;string value of network mask in dotted decimal notation (i.e. 255.255.255.0)&lt;/param&gt;
    /// &lt;returns&gt;Byte value of the CIDR&lt;/returns&gt;
    public byte ip_masktocidr(string Mask) {
      uint mask = ip_iptouint(Mask);
      byte bits = 0;
      for (uint pointer = 0x80000000; (mask &amp; pointer) != 0; pointer &gt;&gt;= 1) {
        bits++;
      }
      return bits;
    }
    /// &lt;summary&gt;
    /// Convert a subnetmask in CIDR notation to an unsigned integer value
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;CIDR&quot;&gt;Subnet mask in CIDR notation&lt;/param&gt;
    /// &lt;returns&gt;Unsigned integer that represents the subnet mask&lt;/returns&gt;
    public uint ip_cidrtouintmask(byte CIDR) {
      return 0xFFFFFFFF &lt;&lt; (32 - CIDR);
    }
    /// &lt;summary&gt;
    /// Convert a subnet mask in CIDR notation to a dotted decimal string value
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;CIDR&quot;&gt;Subnet mask in CIDR notation&lt;/param&gt;
    /// &lt;returns&gt;String value of the subnet mask in dotted decimal notation&lt;/returns&gt;
    public string ip_cidrtomask(byte CIDR) {
      return ip_uinttoip(ip_cidrtouintmask(CIDR));
    }
    /// &lt;summary&gt;
    /// Checks to ensure the network address passed in is a valid subnet address
    /// and validates the network address is in the proper format
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Network&quot;&gt;Network address in the format x.x.x.x/CIDR, x.x.x.x/x.x.x.x or x.x.x.x&lt;/param&gt;
    /// &lt;returns&gt;True if it is a valid network address and false if it is not&lt;/returns&gt;
    public bool ip_is_valid(string Network) {
      if (Network.Contains(&quot;/&quot;)) {
        string[] token = Network.Split('/');
        if (token.Length != 2) return false;
        if (!(ip_is_valid(token[0]))) return false;
        if (token[1].Contains(&quot;.&quot;)) {
          if (!(ip_is_valid(token[1]))) return false;
        } else {
          byte fred = 0;
          if (!(byte.TryParse(token[1], out fred))) return false;
          if (fred &gt; 32) return false;
        }
        uint ipAddr = ip_iptouint(token[0]);
        uint Mask = token[1].Contains(&quot;.&quot;) ? ip_iptouint(token[1]) : ip_cidrtouintmask(byte.Parse(token[1]));

        if (token[1].Contains(&quot;.&quot;)) {
          var tmp1 = String.Join(&quot;&quot;, token[1].Split('.')
            .Select(c =&gt; Convert.ToString(Int32.Parse(c), 2)));
          if (tmp1.Contains(&quot;01&quot;)) return false;
        }

        return ((ipAddr &amp; Mask) == ipAddr);
      } else {
        string[] token = Network.Split('.');
        if (token.Length != 4) return false;
        byte fred = 0;
        foreach (string octet in token) {
          if (!(byte.TryParse(octet, out fred)))
            return false;
        }
        return true;
      }
    }
    /// &lt;summary&gt;
    /// Returns the number of IP address a given mask will support
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Mask&quot;&gt;String value of the mask to use in dotted decimal format&lt;/param&gt;
    /// &lt;returns&gt;Unsigned integer containing the number of IP addresses the passed in mask will support&lt;/returns&gt;
    public uint ip_size(string Mask) {
      return (uint)Math.Pow(2, 32 - (double)ip_masktocidr(Mask));
    }
    /// &lt;summary&gt;
    /// Returns the number of IP address a given CIDR will support
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;CIDR&quot;&gt;Byte value of the CIDR to be used&lt;/param&gt;
    /// &lt;returns&gt;Unsigned integer containing the number of IP addresses the passed in CIDR will support&lt;/returns&gt;
    public uint ip_size(byte CIDR) {
      return (uint)Math.Pow(2, 32 - (double)CIDR);
    }
    /// &lt;summary&gt;
    /// Find the shortest prefix that fit both the first and second IP addresses passed in
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;ip1&quot;&gt;IP address in uint format of the first IP address&lt;/param&gt;
    /// &lt;param name=&quot;ip2&quot;&gt;IP address in uint format of the second IP address&lt;/param&gt;
    /// &lt;returns&gt;The shortest prefix length that will accomodate the two IP addresses passed in&lt;/returns&gt;
    public byte ip_get_prefix_length(uint ip1, uint ip2) {
      byte i = 0;
      for (uint pointer = 1; pointer != 0; pointer &lt;&lt;= 1) {
        if ((ip1 &amp; pointer) == (ip2 &amp; pointer)) {
          return i;
        } else {
          i++;
        }
      }
      return 32;
    }
    /// &lt;summary&gt;
    /// Returns the broadcast address of the network and subnet sent to it
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Network&quot;&gt;An unsigned integer value of the network&lt;/param&gt;
    /// &lt;param name=&quot;Subnet&quot;&gt;An unsigned integer value of the subnet mask&lt;/param&gt;
    /// &lt;returns&gt;The unsigned IP address of the broadcast address for this subnet&lt;/returns&gt;
    public uint ip_broadcastAddress(uint Network, uint Subnet) {
      return (Network | (0xFFFFFFFF ^ Subnet));
    }
    /// &lt;summary&gt;
    /// Returns the broadcast address of the network and subnet sent to it
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Network&quot;&gt;string value of the network&lt;/param&gt;
    /// &lt;param name=&quot;Subnet&quot;&gt;string value of the subnet mask&lt;/param&gt;
    /// &lt;returns&gt;String of the IP address of the broadcast address for this subnet&lt;/returns&gt;
    public string ip_broadcastAddress(string Network, string Subnet) {
      return ip_uinttoip(ip_broadcastAddress(ip_iptouint(Network), ip_iptouint(Subnet)));
    }
    /// &lt;summary&gt;
    /// Returns the Network Address as unsigned int
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Network&quot;&gt;Address as unsigned int&lt;/param&gt;
    /// &lt;param name=&quot;Subnet&quot;&gt;Subnet mask as unsigned int&lt;/param&gt;
    /// &lt;returns&gt;Returns unsigned int of broadcast address&lt;/returns&gt;
    public uint ip_networkAddress(uint Network, uint Subnet) {
      return (Subnet &amp; Network);
    }
    /// &lt;summary&gt;
    /// Returns the Network Address as a string
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Network&quot;&gt;Address as a string&lt;/param&gt;
    /// &lt;param name=&quot;Subnet&quot;&gt;Subnet mask as a string&lt;/param&gt;
    /// &lt;returns&gt;Returns unsigned int of broadcast address&lt;/returns&gt;
    public string ip_networkAddress(string Network, string Subnet) {
      return ip_uinttoip(ip_networkAddress(ip_iptouint(Network), ip_iptouint(Subnet)));
    }
    /// &lt;summary&gt;
    /// Returns the starting and ending host addresses in the network provided
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Network&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public ArrayList ip_range(string Network) {
      ArrayList retValue = new ArrayList();
      string[] token = Network.Split('/');
      uint ipAddr = ip_iptouint(token[0]);
      retValue.Add(ip_uinttoip(ipAddr + 1));
      if (token[1].Contains(&quot;.&quot;)) {
        retValue.Add(ip_uinttoip(ipAddr + ip_size(token[1]) - 1));
      } else {
        retValue.Add(ip_uinttoip(ipAddr + ip_size(byte.Parse(token[1])) - 1));
      }
      return (retValue);
    }
  } </code></pre></noscript></div>


<h1>The Tests</h1>

<p>Here are a few test to ensure the validity of the IPHelper class. I know there are probably a lot more test I could create, but right now this has covered everything. So far so good.</p>

<div><script src='https://gist.github.com/2884281.js?file=IPHelperTests.cs'></script>
<noscript><pre><code>[TestFixture]
  public class IPHelperTests {

    [TestCase(&quot;10.0.0.0/24&quot;, &quot;10.0.0.27&quot;)]
    [TestCase(&quot;10.0.0.0/255.255.254.0&quot;, &quot;10.0.1.27&quot;)]
    public void validates_valid_addresses_inside_given_range_returns_true(string range, string address) {

      var ipHelp = new IPHelper();

      bool result = ipHelp.ip_inside_range(range, address);

      Assert.IsTrue(result);
    }

    [TestCase(&quot;10.0.0.0/23&quot;, &quot;10.0.3.27&quot;)]
    [TestCase(&quot;10.0.0.0/255.255.254.0&quot;, &quot;10.0.3.27&quot;)]
    public void validates_invalid_addresses_outside_given_range_returns_false(string range, string address) {

      var ipHelp = new IPHelper();

      bool result = ipHelp.ip_inside_range(range, address);

      Assert.IsFalse(result);
    }

    [TestCase(&quot;10.0.1.0&quot;)]
    [TestCase(&quot;10.0.1.0/24&quot;)]
    [TestCase(&quot;10.0.1.0/255.255.255.0&quot;)]
    public void validates_ip_is_valid_given_valid_ip_addresses_returns_true(string address) {

      var ipHelp = new IPHelper();

      bool result = ipHelp.ip_is_valid(address);

      Assert.IsTrue(result);
    }

    [TestCase(&quot;10.0.257.0&quot;)]
    [TestCase(&quot;10.0.1.0/23&quot;)]
    [TestCase(&quot;10.0.1.0/255.0.255.0&quot;)]
    [TestCase(&quot;10.0.0.0/255.257.255.0&quot;)]
    public void validates_ip_is_valid_given_invalid_ip_addresses_returns_false(string address) {

      var ipHelp = new IPHelper();

      bool result = ipHelp.ip_is_valid(address);

      Assert.IsFalse(result);
    }


    [Test]
    public void validate_ip_cidrtounintmask() {

      var ipHelp = new IPHelper();

      uint result = ipHelp.ip_cidrtouintmask(24);

      Assert.AreEqual(4294967040, result);

    }

    [Test]
    public void validate_ip_cidrtomask() {

      var ipHelp = new IPHelper();

      string result = ipHelp.ip_cidrtomask(24);

      Assert.AreEqual(&quot;255.255.255.0&quot;, result);

    }

    [Test]
    public void validate_ip_uinttoip() {

      var ipHelp = new IPHelper();

      string result = ipHelp.ip_uinttoip(4294967040);

      Assert.AreEqual(&quot;255.255.255.0&quot;, result);

    }

    [Test]
    public void validate_ip_iptouint() {

      var ipHelp = new IPHelper();

      uint result = ipHelp.ip_iptouint(&quot;10.0.0.0&quot;);

      Assert.AreEqual(Convert.ToUInt32(167772160), result);

    }

    [Test]
    public void validate_ip_masktocidr() {

      var ipHelp = new IPHelper();

      byte result = ipHelp.ip_masktocidr(&quot;255.255.255.0&quot;);

      Assert.AreEqual(Convert.ToByte(24), result);

    }

    [Test]
    public void validate_ip_size() {

      var ipHelp = new IPHelper();

      uint result1 = ipHelp.ip_size(&quot;255.255.0.0&quot;);
      uint result2 = ipHelp.ip_size(15);

      Assert.AreEqual(Convert.ToUInt32(65536), result1);
      Assert.AreEqual(Convert.ToUInt32(131072), result2);

    }

    [Test]
    public void validate_ip_get_prefix_length() {

      var ipHelp = new IPHelper();
      var ip1 = ipHelp.ip_iptouint(&quot;192.168.0.0&quot;);
      var ip2 = ipHelp.ip_iptouint(&quot;192.168.0.127&quot;);
      byte result = ipHelp.ip_get_prefix_length(ip1, ip2);

      Assert.AreEqual(Convert.ToByte(7), result);

    }

    [Test]
    public void validate_ip_broadcastAddress() {

      var ipHelp = new IPHelper();
      var ip1 = 3232235520; //192.168.0.0
      var ip2 = 4294966784; //255.255.254.0
      uint result_uint = ipHelp.ip_broadcastAddress(ip1, ip2);
      string result_string = ipHelp.ip_broadcastAddress(&quot;192.168.0.0&quot;, &quot;255.255.254.0&quot;);

      Assert.AreEqual(Convert.ToUInt32(3232236031), result_uint);
      Assert.AreEqual(&quot;192.168.1.255&quot;, result_string);
    }

    [Test]
    public void validate_ip_networkAddress() {

      var ipHelp = new IPHelper();
      var ip1 = 3232235520; //192.168.0.0
      var ip2 = 4294966784; //255.255.254.0
      uint result_uint = ipHelp.ip_networkAddress(ip1, ip2);
      string result_string = ipHelp.ip_networkAddress(&quot;192.168.1.0&quot;, &quot;255.255.254.0&quot;);

      Assert.AreEqual(Convert.ToUInt32(3232235520), result_uint);
      Assert.AreEqual(&quot;192.168.0.0&quot;, result_string);
    }

    [Test]
    public void validate_ip_range() {

      var ipHelp = new IPHelper();
      ArrayList result1 = ipHelp.ip_range(&quot;192.168.0.0/22&quot;);
      ArrayList result2 = ipHelp.ip_range(&quot;192.168.0.2/27&quot;);

      Assert.AreEqual(&quot;192.168.0.1&quot;, result1[0]);
      Assert.AreEqual(&quot;192.168.3.255&quot;, result1[1]);

      Assert.AreEqual(&quot;192.168.0.3&quot;, result2[0]);
      Assert.AreEqual(&quot;192.168.0.33&quot;, result2[1]);

    }


    [TestCase(&quot;0.0.0.0&quot;)]
    [TestCase(&quot;10.0.1.0&quot;)]
    [TestCase(&quot;10.0.1.0&quot;)]
    [TestCase(&quot;255.255.255.255&quot;)]
    public void validate_valid_ip_correctly_identifies_valid_addresses(string address) {

      var ipHelp = new IPHelper();

      bool result = ipHelp.valid_ip(address);

      Assert.IsTrue(result);

    }

    [TestCase(&quot;256.0.0.0&quot;)]
    [TestCase(&quot;1.256.0.0&quot;)]
    [TestCase(&quot;1.1.256.0&quot;)]
    [TestCase(&quot;1.1.1.256&quot;)]
    public void validate_valid_ip_correctly_identifies_invalid_addresses(string address) {

      var ipHelp = new IPHelper();

      bool result = ipHelp.valid_ip(address);

      Assert.IsFalse(result);

    }
  }</code></pre></noscript></div>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Kyle Rogers</span></span>

      








  


<time datetime="2012-06-06T15:35:00-05:00" pubdate data-updated="true">Jun 6<span>th</span>, 2012</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/asp-dot-net/'>ASP.NET,</a>, <a class='category' href='/blog/categories/mvc/'>MVC</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://keroger2k.github.io/blog/2012/06/06/system-dot-net-dot-ip-dot-address-shortcomings/" data-via="keroger2k" data-counturl="http://keroger2k.github.io/blog/2012/06/06/system-dot-net-dot-ip-dot-address-shortcomings/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2012/06/01/up-and-running-with-sinatra/" title="Previous Post: Up and running with Sinatra">&laquo; Up and running with Sinatra</a>
      
      
        <a class="basic-alignment right" href="/blog/2012/06/17/happy-fathers-day/" title="Next Post: Happy Fathers Day">Happy Fathers Day &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <a href="http://stackoverflow.com/users/342706/kyle-rogers">
<img src="http://stackoverflow.com/users/flair/342706.png" width="208" height="58" alt="profile for Kyle Rogers at Stack Overflow, Q&amp;A for professional and enthusiast programmers" title="profile for Kyle Rogers at Stack Overflow, Q&amp;A for professional and enthusiast programmers">
</a><section style="margin-top: 10px;">
  <span>Hello I'm <strong>Kyle Rogers</strong></span>
  <p>I'm a Microsoft Certified Software Developer (MCSD), mainly focused on MVC and Webforms. I have over 5 years software development experience and many more years of experience in the Information Technology Industry.</p>
  <p>I live in the middle of the country in <strong>Bloomington, IL</strong>.  You can contact me at <strong><a href="mailto:kyle.rogers@gmail.com">kyle.rogers@gmail.com</a></strong> or <strong><a href='/about'>read more about me</a></strong>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/03/29/migrating-from-ios-to-android/">Migrating From iOS to Android</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/21/max-width-and-min-width-media-queries-in-internet-explorer-8-and-below/">Max-width and Min-width Media Queries in Internet Explorer 8 and Below</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/20/cisco-hash-perl-port-to-c-number/">Cisco::Hash Perl Port to C#</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/09/20/enums-to-selectlist/">Enums to SelectList</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/17/happy-fathers-day/">Happy Fathers Day</a>
      </li>
    
  </ul>
</section>
<a class="twitter-timeline" href="https://twitter.com/keroger2k" data-widget-id="369935586393485312">Tweets by @keroger2k</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/keroger2k">@keroger2k</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'keroger2k',
            count: 3,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>



<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/kyle.rogers@gmail.com?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Kyle Rogers -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'watersoundway';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://keroger2k.github.io/blog/2012/06/06/system-dot-net-dot-ip-dot-address-shortcomings/';
        var disqus_url = 'http://keroger2k.github.io/blog/2012/06/06/system-dot-net-dot-ip-dot-address-shortcomings/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
