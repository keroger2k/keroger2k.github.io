<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ASP.NET, | Kyle Rogers]]></title>
  <link href="http://keroger2k.github.io/blog/categories/asp-dot-net/atom.xml" rel="self"/>
  <link href="http://keroger2k.github.io/"/>
  <updated>2013-08-21T21:48:26-05:00</updated>
  <id>http://keroger2k.github.io/</id>
  <author>
    <name><![CDATA[Kyle Rogers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Enums to SelectList]]></title>
    <link href="http://keroger2k.github.io/blog/2012/09/20/enums-to-selectlist/"/>
    <updated>2012-09-20T16:48:00-05:00</updated>
    <id>http://keroger2k.github.io/blog/2012/09/20/enums-to-selectlist</id>
    <content type="html"><![CDATA[<p>Recently I had an interview where I was sharing my screen to a couple people who were watching me struggle through the simple task they had me complete.  I had to create a simple drop down list that contain three values and my first thought for whatever reason was to use an Enum and just bind that to a drop down list with the HTML helper object.  However, it had been awhile since I had actually had to do that and after about 1 minute of trying to get it to work I simply gave up and moved on as  I was on the clock.  After the interview I looked back at some code that I currently maintain and found my solution.  It definitely brought back some of the pain that went into the initial implementation.  Although the answer is quite simple, during the pressure of an interview I just couldnâ€™t recall.
Basically, I just used a generic extension method off of type TEnum.  This allows you to just reference a single value of the Enum do a ToSelectList();</p>

<p><div><script src='https://gist.github.com/3726104.js?file=EnumExtensions.cs'></script>
<noscript><pre><code>
    public static SelectList ToSelectList&lt;TEnum&gt;(this TEnum enumObj) 
    {

        var values = from TEnum e in Enum.GetValues(typeof(TEnum))
                     select new { Value = e, Text = e.ToString() };

        return new SelectList(values, &quot;Value&quot;, &quot;Text&quot;, enumObj);
    }</code></pre></noscript></div>
</p>

<p>Here is an example usage:</p>

<p><div><script src='https://gist.github.com/3726104.js?file=HomeController.cs'></script>
<noscript><pre><code>  
    public enum QueryTypes
    {
        Web,
        Images,
        Documents
    }


    public class HomeController : Controller
    {
        public ActionResult Index()
        {
            ViewBag.Select = typeof(QueryTypes).ToSelectList();
            return View();
        }
    }</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[System.Net.IP.Address Shortcomings]]></title>
    <link href="http://keroger2k.github.io/blog/2012/06/06/system-dot-net-dot-ip-dot-address-shortcomings/"/>
    <updated>2012-06-06T15:35:00-05:00</updated>
    <id>http://keroger2k.github.io/blog/2012/06/06/system-dot-net-dot-ip-dot-address-shortcomings</id>
    <content type="html"><![CDATA[<h1>Overview</h1>

<p>Perhaps I&rsquo;m going about this completely the wrong way, but from what I can tell, there really isn&rsquo;t much logic built into the framework for IP Addressing and C#. There is a <a href="http://msdn.microsoft.com/en-us/library/system.net.ipaddress.aspx">System.Net.IPAddress</a> class that has some very limited capabilities IMO. I just don&rsquo;t understand why there isn&rsquo;t some additional functionality with this class or some sister class that helps simplify common tasks with IP address functionality. For example an IP address is mostly useless alone. Without a subnet mask you have no real sense of the IP address. Once you have the subnet mask you then can extrapolate all the details such as network address, broadcast address, size, etc&hellip; I wish the System.Net.IPAddress class allowed you to do more things like this natively.</p>

<p>Below are a few methods to help extend on the logic of System.Net.IPAddress. I thought I&rsquo;d share what has been completed so far. I&rsquo;ve also included the NUnit test cases that go along with this class to help with understanding what each of the methods are doing.</p>

<h1>The Code</h1>

<p><div><script src='https://gist.github.com/2884281.js?file=IPHelper.cs'></script>
<noscript><pre><code>public class IPHelper : IIPHelper {
    /// &lt;summary&gt;
    /// Verifies IP Address is Valid
    /// &lt;/summary&gt;
    public bool ip_inside_range(string subnet, string ipAddress) {
      string[] token = subnet.Split('/');
      string mask = token[1].Contains(&quot;.&quot;) ? token[1] : ip_cidrtomask(byte.Parse(token[1]));
      uint networkAddress = ip_iptouint(ip_networkAddress(token[0], mask));
      uint broadcastAddress = ip_iptouint(ip_broadcastAddress(token[0], mask));
      uint ip = ip_iptouint(ipAddress);
      return (networkAddress &lt; ip &amp;&amp; ip &lt; broadcastAddress);
    }
    /// &lt;summary&gt;
    /// Verifies IP Address is Valid
    /// &lt;/summary&gt;
    public bool valid_ip(string address) {
      try {
        IPAddress test = IPAddress.Parse(address);
        return true;
      } catch (FormatException) {
        return false;
      }
    }
    /// &lt;summary&gt;
    /// Takes an IP address string value in dotted decial format and convert it to a uint value
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;ip&quot;&gt;String value of the IP address in dotted decimal format (i.e. 192.168.10.1)&lt;/param&gt;
    /// &lt;returns&gt;Unsigned integer value that represents the IP address passed in&lt;/returns&gt;
    public uint ip_iptouint(string ip) {
      IPAddress i = IPAddress.Parse(ip);
      byte[] ipByteArray = i.GetAddressBytes();

      uint ipUint = (uint)ipByteArray[0] &lt;&lt; 24;
      ipUint += (uint)ipByteArray[1] &lt;&lt; 16;
      ipUint += (uint)ipByteArray[2] &lt;&lt; 8;
      ipUint += (uint)ipByteArray[3];

      return ipUint;
    }
    /// &lt;summary&gt;
    /// Convert a uint IP address value to a string value in dotted decimal format
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;ip&quot;&gt;Unsigned integer value of IP address&lt;/param&gt;
    /// &lt;returns&gt;String value of the IP address in dotted decimal format&lt;/returns&gt;
    public string ip_uinttoip(uint ip) {
      IPAddress i = new IPAddress(ip);
      string[] ipArray = i.ToString().Split('.');
      
      return ipArray[3] + &quot;.&quot; + ipArray[2] + &quot;.&quot; + ipArray[1] + &quot;.&quot; + ipArray[0];
    }
    /// &lt;summary&gt;
    /// Converts the subnet mask into CIDR notation
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Mask&quot;&gt;string value of network mask in dotted decimal notation (i.e. 255.255.255.0)&lt;/param&gt;
    /// &lt;returns&gt;Byte value of the CIDR&lt;/returns&gt;
    public byte ip_masktocidr(string Mask) {
      uint mask = ip_iptouint(Mask);
      byte bits = 0;
      for (uint pointer = 0x80000000; (mask &amp; pointer) != 0; pointer &gt;&gt;= 1) {
        bits++;
      }
      return bits;
    }
    /// &lt;summary&gt;
    /// Convert a subnetmask in CIDR notation to an unsigned integer value
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;CIDR&quot;&gt;Subnet mask in CIDR notation&lt;/param&gt;
    /// &lt;returns&gt;Unsigned integer that represents the subnet mask&lt;/returns&gt;
    public uint ip_cidrtouintmask(byte CIDR) {
      return 0xFFFFFFFF &lt;&lt; (32 - CIDR);
    }
    /// &lt;summary&gt;
    /// Convert a subnet mask in CIDR notation to a dotted decimal string value
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;CIDR&quot;&gt;Subnet mask in CIDR notation&lt;/param&gt;
    /// &lt;returns&gt;String value of the subnet mask in dotted decimal notation&lt;/returns&gt;
    public string ip_cidrtomask(byte CIDR) {
      return ip_uinttoip(ip_cidrtouintmask(CIDR));
    }
    /// &lt;summary&gt;
    /// Checks to ensure the network address passed in is a valid subnet address
    /// and validates the network address is in the proper format
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Network&quot;&gt;Network address in the format x.x.x.x/CIDR, x.x.x.x/x.x.x.x or x.x.x.x&lt;/param&gt;
    /// &lt;returns&gt;True if it is a valid network address and false if it is not&lt;/returns&gt;
    public bool ip_is_valid(string Network) {
      if (Network.Contains(&quot;/&quot;)) {
        string[] token = Network.Split('/');
        if (token.Length != 2) return false;
        if (!(ip_is_valid(token[0]))) return false;
        if (token[1].Contains(&quot;.&quot;)) {
          if (!(ip_is_valid(token[1]))) return false;
        } else {
          byte fred = 0;
          if (!(byte.TryParse(token[1], out fred))) return false;
          if (fred &gt; 32) return false;
        }
        uint ipAddr = ip_iptouint(token[0]);
        uint Mask = token[1].Contains(&quot;.&quot;) ? ip_iptouint(token[1]) : ip_cidrtouintmask(byte.Parse(token[1]));

        if (token[1].Contains(&quot;.&quot;)) {
          var tmp1 = String.Join(&quot;&quot;, token[1].Split('.')
            .Select(c =&gt; Convert.ToString(Int32.Parse(c), 2)));
          if (tmp1.Contains(&quot;01&quot;)) return false;
        }

        return ((ipAddr &amp; Mask) == ipAddr);
      } else {
        string[] token = Network.Split('.');
        if (token.Length != 4) return false;
        byte fred = 0;
        foreach (string octet in token) {
          if (!(byte.TryParse(octet, out fred)))
            return false;
        }
        return true;
      }
    }
    /// &lt;summary&gt;
    /// Returns the number of IP address a given mask will support
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Mask&quot;&gt;String value of the mask to use in dotted decimal format&lt;/param&gt;
    /// &lt;returns&gt;Unsigned integer containing the number of IP addresses the passed in mask will support&lt;/returns&gt;
    public uint ip_size(string Mask) {
      return (uint)Math.Pow(2, 32 - (double)ip_masktocidr(Mask));
    }
    /// &lt;summary&gt;
    /// Returns the number of IP address a given CIDR will support
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;CIDR&quot;&gt;Byte value of the CIDR to be used&lt;/param&gt;
    /// &lt;returns&gt;Unsigned integer containing the number of IP addresses the passed in CIDR will support&lt;/returns&gt;
    public uint ip_size(byte CIDR) {
      return (uint)Math.Pow(2, 32 - (double)CIDR);
    }
    /// &lt;summary&gt;
    /// Find the shortest prefix that fit both the first and second IP addresses passed in
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;ip1&quot;&gt;IP address in uint format of the first IP address&lt;/param&gt;
    /// &lt;param name=&quot;ip2&quot;&gt;IP address in uint format of the second IP address&lt;/param&gt;
    /// &lt;returns&gt;The shortest prefix length that will accomodate the two IP addresses passed in&lt;/returns&gt;
    public byte ip_get_prefix_length(uint ip1, uint ip2) {
      byte i = 0;
      for (uint pointer = 1; pointer != 0; pointer &lt;&lt;= 1) {
        if ((ip1 &amp; pointer) == (ip2 &amp; pointer)) {
          return i;
        } else {
          i++;
        }
      }
      return 32;
    }
    /// &lt;summary&gt;
    /// Returns the broadcast address of the network and subnet sent to it
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Network&quot;&gt;An unsigned integer value of the network&lt;/param&gt;
    /// &lt;param name=&quot;Subnet&quot;&gt;An unsigned integer value of the subnet mask&lt;/param&gt;
    /// &lt;returns&gt;The unsigned IP address of the broadcast address for this subnet&lt;/returns&gt;
    public uint ip_broadcastAddress(uint Network, uint Subnet) {
      return (Network | (0xFFFFFFFF ^ Subnet));
    }
    /// &lt;summary&gt;
    /// Returns the broadcast address of the network and subnet sent to it
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Network&quot;&gt;string value of the network&lt;/param&gt;
    /// &lt;param name=&quot;Subnet&quot;&gt;string value of the subnet mask&lt;/param&gt;
    /// &lt;returns&gt;String of the IP address of the broadcast address for this subnet&lt;/returns&gt;
    public string ip_broadcastAddress(string Network, string Subnet) {
      return ip_uinttoip(ip_broadcastAddress(ip_iptouint(Network), ip_iptouint(Subnet)));
    }
    /// &lt;summary&gt;
    /// Returns the Network Address as unsigned int
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Network&quot;&gt;Address as unsigned int&lt;/param&gt;
    /// &lt;param name=&quot;Subnet&quot;&gt;Subnet mask as unsigned int&lt;/param&gt;
    /// &lt;returns&gt;Returns unsigned int of broadcast address&lt;/returns&gt;
    public uint ip_networkAddress(uint Network, uint Subnet) {
      return (Subnet &amp; Network);
    }
    /// &lt;summary&gt;
    /// Returns the Network Address as a string
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Network&quot;&gt;Address as a string&lt;/param&gt;
    /// &lt;param name=&quot;Subnet&quot;&gt;Subnet mask as a string&lt;/param&gt;
    /// &lt;returns&gt;Returns unsigned int of broadcast address&lt;/returns&gt;
    public string ip_networkAddress(string Network, string Subnet) {
      return ip_uinttoip(ip_networkAddress(ip_iptouint(Network), ip_iptouint(Subnet)));
    }
    /// &lt;summary&gt;
    /// Returns the starting and ending host addresses in the network provided
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;Network&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public ArrayList ip_range(string Network) {
      ArrayList retValue = new ArrayList();
      string[] token = Network.Split('/');
      uint ipAddr = ip_iptouint(token[0]);
      retValue.Add(ip_uinttoip(ipAddr + 1));
      if (token[1].Contains(&quot;.&quot;)) {
        retValue.Add(ip_uinttoip(ipAddr + ip_size(token[1]) - 1));
      } else {
        retValue.Add(ip_uinttoip(ipAddr + ip_size(byte.Parse(token[1])) - 1));
      }
      return (retValue);
    }
  } </code></pre></noscript></div>
</p>

<h1>The Tests</h1>

<p>Here are a few test to ensure the validity of the IPHelper class. I know there are probably a lot more test I could create, but right now this has covered everything. So far so good.</p>

<p><div><script src='https://gist.github.com/2884281.js?file=IPHelperTests.cs'></script>
<noscript><pre><code>[TestFixture]
  public class IPHelperTests {

    [TestCase(&quot;10.0.0.0/24&quot;, &quot;10.0.0.27&quot;)]
    [TestCase(&quot;10.0.0.0/255.255.254.0&quot;, &quot;10.0.1.27&quot;)]
    public void validates_valid_addresses_inside_given_range_returns_true(string range, string address) {

      var ipHelp = new IPHelper();

      bool result = ipHelp.ip_inside_range(range, address);

      Assert.IsTrue(result);
    }

    [TestCase(&quot;10.0.0.0/23&quot;, &quot;10.0.3.27&quot;)]
    [TestCase(&quot;10.0.0.0/255.255.254.0&quot;, &quot;10.0.3.27&quot;)]
    public void validates_invalid_addresses_outside_given_range_returns_false(string range, string address) {

      var ipHelp = new IPHelper();

      bool result = ipHelp.ip_inside_range(range, address);

      Assert.IsFalse(result);
    }

    [TestCase(&quot;10.0.1.0&quot;)]
    [TestCase(&quot;10.0.1.0/24&quot;)]
    [TestCase(&quot;10.0.1.0/255.255.255.0&quot;)]
    public void validates_ip_is_valid_given_valid_ip_addresses_returns_true(string address) {

      var ipHelp = new IPHelper();

      bool result = ipHelp.ip_is_valid(address);

      Assert.IsTrue(result);
    }

    [TestCase(&quot;10.0.257.0&quot;)]
    [TestCase(&quot;10.0.1.0/23&quot;)]
    [TestCase(&quot;10.0.1.0/255.0.255.0&quot;)]
    [TestCase(&quot;10.0.0.0/255.257.255.0&quot;)]
    public void validates_ip_is_valid_given_invalid_ip_addresses_returns_false(string address) {

      var ipHelp = new IPHelper();

      bool result = ipHelp.ip_is_valid(address);

      Assert.IsFalse(result);
    }


    [Test]
    public void validate_ip_cidrtounintmask() {

      var ipHelp = new IPHelper();

      uint result = ipHelp.ip_cidrtouintmask(24);

      Assert.AreEqual(4294967040, result);

    }

    [Test]
    public void validate_ip_cidrtomask() {

      var ipHelp = new IPHelper();

      string result = ipHelp.ip_cidrtomask(24);

      Assert.AreEqual(&quot;255.255.255.0&quot;, result);

    }

    [Test]
    public void validate_ip_uinttoip() {

      var ipHelp = new IPHelper();

      string result = ipHelp.ip_uinttoip(4294967040);

      Assert.AreEqual(&quot;255.255.255.0&quot;, result);

    }

    [Test]
    public void validate_ip_iptouint() {

      var ipHelp = new IPHelper();

      uint result = ipHelp.ip_iptouint(&quot;10.0.0.0&quot;);

      Assert.AreEqual(Convert.ToUInt32(167772160), result);

    }

    [Test]
    public void validate_ip_masktocidr() {

      var ipHelp = new IPHelper();

      byte result = ipHelp.ip_masktocidr(&quot;255.255.255.0&quot;);

      Assert.AreEqual(Convert.ToByte(24), result);

    }

    [Test]
    public void validate_ip_size() {

      var ipHelp = new IPHelper();

      uint result1 = ipHelp.ip_size(&quot;255.255.0.0&quot;);
      uint result2 = ipHelp.ip_size(15);

      Assert.AreEqual(Convert.ToUInt32(65536), result1);
      Assert.AreEqual(Convert.ToUInt32(131072), result2);

    }

    [Test]
    public void validate_ip_get_prefix_length() {

      var ipHelp = new IPHelper();
      var ip1 = ipHelp.ip_iptouint(&quot;192.168.0.0&quot;);
      var ip2 = ipHelp.ip_iptouint(&quot;192.168.0.127&quot;);
      byte result = ipHelp.ip_get_prefix_length(ip1, ip2);

      Assert.AreEqual(Convert.ToByte(7), result);

    }

    [Test]
    public void validate_ip_broadcastAddress() {

      var ipHelp = new IPHelper();
      var ip1 = 3232235520; //192.168.0.0
      var ip2 = 4294966784; //255.255.254.0
      uint result_uint = ipHelp.ip_broadcastAddress(ip1, ip2);
      string result_string = ipHelp.ip_broadcastAddress(&quot;192.168.0.0&quot;, &quot;255.255.254.0&quot;);

      Assert.AreEqual(Convert.ToUInt32(3232236031), result_uint);
      Assert.AreEqual(&quot;192.168.1.255&quot;, result_string);
    }

    [Test]
    public void validate_ip_networkAddress() {

      var ipHelp = new IPHelper();
      var ip1 = 3232235520; //192.168.0.0
      var ip2 = 4294966784; //255.255.254.0
      uint result_uint = ipHelp.ip_networkAddress(ip1, ip2);
      string result_string = ipHelp.ip_networkAddress(&quot;192.168.1.0&quot;, &quot;255.255.254.0&quot;);

      Assert.AreEqual(Convert.ToUInt32(3232235520), result_uint);
      Assert.AreEqual(&quot;192.168.0.0&quot;, result_string);
    }

    [Test]
    public void validate_ip_range() {

      var ipHelp = new IPHelper();
      ArrayList result1 = ipHelp.ip_range(&quot;192.168.0.0/22&quot;);
      ArrayList result2 = ipHelp.ip_range(&quot;192.168.0.2/27&quot;);

      Assert.AreEqual(&quot;192.168.0.1&quot;, result1[0]);
      Assert.AreEqual(&quot;192.168.3.255&quot;, result1[1]);

      Assert.AreEqual(&quot;192.168.0.3&quot;, result2[0]);
      Assert.AreEqual(&quot;192.168.0.33&quot;, result2[1]);

    }


    [TestCase(&quot;0.0.0.0&quot;)]
    [TestCase(&quot;10.0.1.0&quot;)]
    [TestCase(&quot;10.0.1.0&quot;)]
    [TestCase(&quot;255.255.255.255&quot;)]
    public void validate_valid_ip_correctly_identifies_valid_addresses(string address) {

      var ipHelp = new IPHelper();

      bool result = ipHelp.valid_ip(address);

      Assert.IsTrue(result);

    }

    [TestCase(&quot;256.0.0.0&quot;)]
    [TestCase(&quot;1.256.0.0&quot;)]
    [TestCase(&quot;1.1.256.0&quot;)]
    [TestCase(&quot;1.1.1.256&quot;)]
    public void validate_valid_ip_correctly_identifies_invalid_addresses(string address) {

      var ipHelp = new IPHelper();

      bool result = ipHelp.valid_ip(address);

      Assert.IsFalse(result);

    }
  }</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
</feed>
